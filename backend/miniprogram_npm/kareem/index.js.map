{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\n/**\n * Create a new instance\n */\nfunction Kareem() {\n  this._pres = new Map();\n  this._posts = new Map();\n}\n\nKareem.skipWrappedFunction = function skipWrappedFunction() {\n  if (!(this instanceof Kareem.skipWrappedFunction)) {\n    return new Kareem.skipWrappedFunction(...arguments);\n  }\n\n  this.args = [...arguments];\n};\n\nKareem.overwriteResult = function overwriteResult() {\n  if (!(this instanceof Kareem.overwriteResult)) {\n    return new Kareem.overwriteResult(...arguments);\n  }\n\n  this.args = [...arguments];\n};\n\n/**\n * Execute all \"pre\" hooks for \"name\"\n * @param {String} name The hook name to execute\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Array|Function} args Optional arguments or directly the callback\n * @param {Function} [callback] The callback to call when executing all hooks are finished\n * @returns {void}\n */\nKareem.prototype.execPre = function(name, context, args, callback) {\n  if (arguments.length === 3) {\n    callback = args;\n    args = [];\n  }\n  const pres = this._pres.get(name) || [];\n  const numPres = pres.length;\n  const numAsyncPres = pres.numAsync || 0;\n  let currentPre = 0;\n  let asyncPresLeft = numAsyncPres;\n  let done = false;\n  const $args = args;\n  let shouldSkipWrappedFunction = null;\n\n  if (!numPres) {\n    return nextTick(function() {\n      callback(null);\n    });\n  }\n\n  function next() {\n    if (currentPre >= numPres) {\n      return;\n    }\n    const pre = pres[currentPre];\n\n    if (pre.isAsync) {\n      const args = [\n        decorateNextFn(_next),\n        decorateNextFn(function(error) {\n          if (error) {\n            if (done) {\n              return;\n            }\n            if (error instanceof Kareem.skipWrappedFunction) {\n              shouldSkipWrappedFunction = error;\n            } else {\n              done = true;\n              return callback(error);\n            }\n          }\n          if (--asyncPresLeft === 0 && currentPre >= numPres) {\n            return callback(shouldSkipWrappedFunction);\n          }\n        })\n      ];\n\n      callMiddlewareFunction(pre.fn, context, args, args[0]);\n    } else if (pre.fn.length > 0) {\n      const args = [decorateNextFn(_next)];\n      const _args = arguments.length >= 2 ? arguments : [null].concat($args);\n      for (let i = 1; i < _args.length; ++i) {\n        if (i === _args.length - 1 && typeof _args[i] === 'function') {\n          continue; // skip callbacks to avoid accidentally calling the callback from a hook\n        }\n        args.push(_args[i]);\n      }\n\n      callMiddlewareFunction(pre.fn, context, args, args[0]);\n    } else {\n      let maybePromiseLike = null;\n      try {\n        maybePromiseLike = pre.fn.call(context);\n      } catch (err) {\n        if (err != null) {\n          return callback(err);\n        }\n      }\n\n      if (isPromiseLike(maybePromiseLike)) {\n        maybePromiseLike.then(() => _next(), err => _next(err));\n      } else {\n        if (++currentPre >= numPres) {\n          if (asyncPresLeft > 0) {\n            // Leave parallel hooks to run\n            return;\n          } else {\n            return nextTick(function() {\n              callback(shouldSkipWrappedFunction);\n            });\n          }\n        }\n        next();\n      }\n    }\n  }\n\n  next.apply(null, [null].concat(args));\n\n  function _next(error) {\n    if (error) {\n      if (done) {\n        return;\n      }\n      if (error instanceof Kareem.skipWrappedFunction) {\n        shouldSkipWrappedFunction = error;\n      } else {\n        done = true;\n        return callback(error);\n      }\n    }\n\n    if (++currentPre >= numPres) {\n      if (asyncPresLeft > 0) {\n        // Leave parallel hooks to run\n        return;\n      } else {\n        return callback(shouldSkipWrappedFunction);\n      }\n    }\n\n    next.apply(context, arguments);\n  }\n};\n\n/**\n * Execute all \"pre\" hooks for \"name\" synchronously\n * @param {String} name The hook name to execute\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Array} [args] Apply custom arguments to the hook\n * @returns {void}\n */\nKareem.prototype.execPreSync = function(name, context, args) {\n  const pres = this._pres.get(name) || [];\n  const numPres = pres.length;\n\n  for (let i = 0; i < numPres; ++i) {\n    pres[i].fn.apply(context, args || []);\n  }\n};\n\n/**\n * Execute all \"post\" hooks for \"name\"\n * @param {String} name The hook name to execute\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Array|Function} args Apply custom arguments to the hook\n * @param {*} options Optional options or directly the callback\n * @param {Function} [callback] The callback to call when executing all hooks are finished\n * @returns {void}\n */\nKareem.prototype.execPost = function(name, context, args, options, callback) {\n  if (arguments.length < 5) {\n    callback = options;\n    options = null;\n  }\n  const posts = this._posts.get(name) || [];\n  const numPosts = posts.length;\n  let currentPost = 0;\n\n  let firstError = null;\n  if (options && options.error) {\n    firstError = options.error;\n  }\n\n  if (!numPosts) {\n    return nextTick(function() {\n      callback.apply(null, [firstError].concat(args));\n    });\n  }\n\n  function next() {\n    const post = posts[currentPost].fn;\n    let numArgs = 0;\n    const argLength = args.length;\n    const newArgs = [];\n    for (let i = 0; i < argLength; ++i) {\n      numArgs += args[i] && args[i]._kareemIgnore ? 0 : 1;\n      if (!args[i] || !args[i]._kareemIgnore) {\n        newArgs.push(args[i]);\n      }\n    }\n\n    if (firstError) {\n      if (isErrorHandlingMiddleware(posts[currentPost], numArgs)) {\n        const _cb = decorateNextFn(function(error) {\n          if (error) {\n            if (error instanceof Kareem.overwriteResult) {\n              args = error.args;\n              if (++currentPost >= numPosts) {\n                return callback.call(null, firstError);\n              }\n              return next();\n            }\n            firstError = error;\n          }\n          if (++currentPost >= numPosts) {\n            return callback.call(null, firstError);\n          }\n          next();\n        });\n\n        callMiddlewareFunction(post, context,\n          [firstError].concat(newArgs).concat([_cb]), _cb);\n      } else {\n        if (++currentPost >= numPosts) {\n          return callback.call(null, firstError);\n        }\n        next();\n      }\n    } else {\n      const _cb = decorateNextFn(function(error) {\n        if (error) {\n          if (error instanceof Kareem.overwriteResult) {\n            args = error.args;\n            if (++currentPost >= numPosts) {\n              return callback.apply(null, [null].concat(args));\n            }\n            return next();\n          }\n          firstError = error;\n          return next();\n        }\n\n        if (++currentPost >= numPosts) {\n          return callback.apply(null, [null].concat(args));\n        }\n\n        next();\n      });\n\n      if (isErrorHandlingMiddleware(posts[currentPost], numArgs)) {\n        // Skip error handlers if no error\n        if (++currentPost >= numPosts) {\n          return callback.apply(null, [null].concat(args));\n        }\n        return next();\n      }\n      if (post.length === numArgs + 1) {\n        callMiddlewareFunction(post, context, newArgs.concat([_cb]), _cb);\n      } else {\n        let error;\n        let maybePromiseLike;\n        try {\n          maybePromiseLike = post.apply(context, newArgs);\n        } catch (err) {\n          error = err;\n          firstError = err;\n        }\n\n        if (isPromiseLike(maybePromiseLike)) {\n          return maybePromiseLike.then(\n            (res) => {\n              _cb(res instanceof Kareem.overwriteResult ? res : null);\n            },\n            err => _cb(err)\n          );\n        }\n\n        if (maybePromiseLike instanceof Kareem.overwriteResult) {\n          args = maybePromiseLike.args;\n        }\n\n        if (++currentPost >= numPosts) {\n          return callback.apply(null, [error].concat(args));\n        }\n\n        next();\n      }\n    }\n  }\n\n  next();\n};\n\n/**\n * Execute all \"post\" hooks for \"name\" synchronously\n * @param {String} name The hook name to execute\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Array|Function} args Apply custom arguments to the hook\n * @returns {Array} The used arguments\n */\nKareem.prototype.execPostSync = function(name, context, args) {\n  const posts = this._posts.get(name) || [];\n  const numPosts = posts.length;\n\n  for (let i = 0; i < numPosts; ++i) {\n    const res = posts[i].fn.apply(context, args || []);\n    if (res instanceof Kareem.overwriteResult) {\n      args = res.args;\n    }\n  }\n\n  return args;\n};\n\n/**\n * Create a synchronous wrapper for \"fn\"\n * @param {String} name The name of the hook\n * @param {Function} fn The function to wrap\n * @returns {Function} The wrapped function\n */\nKareem.prototype.createWrapperSync = function(name, fn) {\n  const _this = this;\n  return function syncWrapper() {\n    _this.execPreSync(name, this, arguments);\n\n    const toReturn = fn.apply(this, arguments);\n\n    const result = _this.execPostSync(name, this, [toReturn]);\n\n    return result[0];\n  };\n};\n\nfunction _handleWrapError(instance, error, name, context, args, options, callback) {\n  if (options.useErrorHandlers) {\n    return instance.execPost(name, context, args, { error: error }, function(error) {\n      return typeof callback === 'function' && callback(error);\n    });\n  } else {\n    return typeof callback === 'function' && callback(error);\n  }\n}\n\n/**\n * Executes pre hooks, followed by the wrapped function, followed by post hooks.\n * @param {String} name The name of the hook\n * @param {Function} fn The function for the hook\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Array} args Apply custom arguments to the hook\n * @param {Object} [options]\n * @param {Boolean} [options.checkForPromise]\n * @returns {void}\n */\nKareem.prototype.wrap = function(name, fn, context, args, options) {\n  const lastArg = (args.length > 0 ? args[args.length - 1] : null);\n  const argsWithoutCb = Array.from(args);\n  typeof lastArg === 'function' && argsWithoutCb.pop();\n  const _this = this;\n\n  options = options || {};\n  const checkForPromise = options.checkForPromise;\n\n  this.execPre(name, context, args, function(error) {\n    if (error && !(error instanceof Kareem.skipWrappedFunction)) {\n      const numCallbackParams = options.numCallbackParams || 0;\n      const errorArgs = options.contextParameter ? [context] : [];\n      for (let i = errorArgs.length; i < numCallbackParams; ++i) {\n        errorArgs.push(null);\n      }\n      return _handleWrapError(_this, error, name, context, errorArgs,\n        options, lastArg);\n    }\n\n    const numParameters = fn.length;\n    let ret;\n\n    if (error instanceof Kareem.skipWrappedFunction) {\n      ret = error.args[0];\n      return _cb(null, ...error.args);\n    } else {\n      try {\n        ret = fn.apply(context, argsWithoutCb.concat(_cb));\n      } catch (err) {\n        return _cb(err);\n      }\n    }\n\n    if (checkForPromise) {\n      if (isPromiseLike(ret)) {\n        // Thenable, use it\n        return ret.then(\n          res => _cb(null, res),\n          err => _cb(err)\n        );\n      }\n\n      // If `fn()` doesn't have a callback argument and doesn't return a\n      // promise, assume it is sync\n      if (numParameters < argsWithoutCb.length + 1) {\n        return _cb(null, ret);\n      }\n    }\n\n    function _cb() {\n      const argsWithoutError = Array.from(arguments);\n      argsWithoutError.shift();\n      if (options.nullResultByDefault && argsWithoutError.length === 0) {\n        argsWithoutError.push(null);\n      }\n      if (arguments[0]) {\n        // Assume error\n        return _handleWrapError(_this, arguments[0], name, context,\n          argsWithoutError, options, lastArg);\n      } else {\n        _this.execPost(name, context, argsWithoutError, function() {\n          if (lastArg === null) {\n            return;\n          }\n          arguments[0]\n            ? lastArg(arguments[0])\n            : lastArg.apply(context, arguments);\n        });\n      }\n    }\n  });\n};\n\n/**\n * Filter current instance for something specific and return the filtered clone\n * @param {Function} fn The filter function\n * @returns {Kareem} The cloned and filtered instance\n */\nKareem.prototype.filter = function(fn) {\n  const clone = this.clone();\n\n  const pres = Array.from(clone._pres.keys());\n  for (const name of pres) {\n    const hooks = this._pres.get(name).\n      map(h => Object.assign({}, h, { name: name })).\n      filter(fn);\n\n    if (hooks.length === 0) {\n      clone._pres.delete(name);\n      continue;\n    }\n\n    hooks.numAsync = hooks.filter(h => h.isAsync).length;\n\n    clone._pres.set(name, hooks);\n  }\n\n  const posts = Array.from(clone._posts.keys());\n  for (const name of posts) {\n    const hooks = this._posts.get(name).\n      map(h => Object.assign({}, h, { name: name })).\n      filter(fn);\n\n    if (hooks.length === 0) {\n      clone._posts.delete(name);\n      continue;\n    }\n\n    clone._posts.set(name, hooks);\n  }\n\n  return clone;\n};\n\n/**\n * Check for a \"name\" to exist either in pre or post hooks\n * @param {String} name The name of the hook\n * @returns {Boolean} \"true\" if found, \"false\" otherwise\n */\nKareem.prototype.hasHooks = function(name) {\n  return this._pres.has(name) || this._posts.has(name);\n};\n\n/**\n * Create a Wrapper for \"fn\" on \"name\" and return the wrapped function\n * @param {String} name The name of the hook\n * @param {Function} fn The function to wrap\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Object} [options]\n * @returns {Function} The wrapped function\n */\nKareem.prototype.createWrapper = function(name, fn, context, options) {\n  const _this = this;\n  if (!this.hasHooks(name)) {\n    // Fast path: if there's no hooks for this function, just return the\n    // function wrapped in a nextTick()\n    return function() {\n      nextTick(() => fn.apply(this, arguments));\n    };\n  }\n  return function() {\n    const _context = context || this;\n    _this.wrap(name, fn, _context, Array.from(arguments), options);\n  };\n};\n\n/**\n * Register a new hook for \"pre\"\n * @param {String} name The name of the hook\n * @param {Boolean} [isAsync]\n * @param {Function} fn The function to register for \"name\"\n * @param {never} error Unused\n * @param {Boolean} [unshift] Wheter to \"push\" or to \"unshift\" the new hook\n * @returns {Kareem}\n */\nKareem.prototype.pre = function(name, isAsync, fn, error, unshift) {\n  let options = {};\n  if (typeof isAsync === 'object' && isAsync !== null) {\n    options = isAsync;\n    isAsync = options.isAsync;\n  } else if (typeof arguments[1] !== 'boolean') {\n    fn = isAsync;\n    isAsync = false;\n  }\n\n  const pres = this._pres.get(name) || [];\n  this._pres.set(name, pres);\n\n  if (isAsync) {\n    pres.numAsync = pres.numAsync || 0;\n    ++pres.numAsync;\n  }\n\n  if (typeof fn !== 'function') {\n    throw new Error('pre() requires a function, got \"' + typeof fn + '\"');\n  }\n\n  if (unshift) {\n    pres.unshift(Object.assign({}, options, { fn: fn, isAsync: isAsync }));\n  } else {\n    pres.push(Object.assign({}, options, { fn: fn, isAsync: isAsync }));\n  }\n\n  return this;\n};\n\n/**\n * Register a new hook for \"post\"\n * @param {String} name The name of the hook\n * @param {Object} [options]\n * @param {Function} fn The function to register for \"name\"\n * @param {Boolean} [unshift] Wheter to \"push\" or to \"unshift\" the new hook\n * @returns {Kareem}\n */\nKareem.prototype.post = function(name, options, fn, unshift) {\n  const posts = this._posts.get(name) || [];\n\n  if (typeof options === 'function') {\n    unshift = !!fn;\n    fn = options;\n    options = {};\n  }\n\n  if (typeof fn !== 'function') {\n    throw new Error('post() requires a function, got \"' + typeof fn + '\"');\n  }\n\n  if (unshift) {\n    posts.unshift(Object.assign({}, options, { fn: fn }));\n  } else {\n    posts.push(Object.assign({}, options, { fn: fn }));\n  }\n  this._posts.set(name, posts);\n  return this;\n};\n\n/**\n * Clone the current instance\n * @returns {Kareem} The cloned instance\n */\nKareem.prototype.clone = function() {\n  const n = new Kareem();\n\n  for (const key of this._pres.keys()) {\n    const clone = this._pres.get(key).slice();\n    clone.numAsync = this._pres.get(key).numAsync;\n    n._pres.set(key, clone);\n  }\n  for (const key of this._posts.keys()) {\n    n._posts.set(key, this._posts.get(key).slice());\n  }\n\n  return n;\n};\n\n/**\n * Merge \"other\" into self or \"clone\"\n * @param {Kareem} other The instance to merge with\n * @param {Kareem} [clone] The instance to merge onto (if not defined, using \"this\")\n * @returns {Kareem} The merged instance\n */\nKareem.prototype.merge = function(other, clone) {\n  clone = arguments.length === 1 ? true : clone;\n  const ret = clone ? this.clone() : this;\n\n  for (const key of other._pres.keys()) {\n    const sourcePres = ret._pres.get(key) || [];\n    const deduplicated = other._pres.get(key).\n      // Deduplicate based on `fn`\n      filter(p => sourcePres.map(_p => _p.fn).indexOf(p.fn) === -1);\n    const combined = sourcePres.concat(deduplicated);\n    combined.numAsync = sourcePres.numAsync || 0;\n    combined.numAsync += deduplicated.filter(p => p.isAsync).length;\n    ret._pres.set(key, combined);\n  }\n  for (const key of other._posts.keys()) {\n    const sourcePosts = ret._posts.get(key) || [];\n    const deduplicated = other._posts.get(key).\n      filter(p => sourcePosts.indexOf(p) === -1);\n    ret._posts.set(key, sourcePosts.concat(deduplicated));\n  }\n\n  return ret;\n};\n\nfunction callMiddlewareFunction(fn, context, args, next) {\n  let maybePromiseLike;\n  try {\n    maybePromiseLike = fn.apply(context, args);\n  } catch (error) {\n    return next(error);\n  }\n\n  if (isPromiseLike(maybePromiseLike)) {\n    maybePromiseLike.then(() => next(), err => next(err));\n  }\n}\n\nfunction isPromiseLike(v) {\n  return (typeof v === 'object' && v !== null && typeof v.then === 'function');\n}\n\nfunction decorateNextFn(fn) {\n  let called = false;\n  const _this = this;\n  return function() {\n    // Ensure this function can only be called once\n    if (called) {\n      return;\n    }\n    called = true;\n    // Make sure to clear the stack so try/catch doesn't catch errors\n    // in subsequent middleware\n    return nextTick(() => fn.apply(_this, arguments));\n  };\n}\n\nconst nextTick = typeof process === 'object' && process !== null && process.nextTick || function nextTick(cb) {\n  setTimeout(cb, 0);\n};\n\nfunction isErrorHandlingMiddleware(post, numArgs) {\n  if (post.errorHandler) {\n    return true;\n  }\n  return post.fn.length === numArgs + 2;\n}\n\nmodule.exports = Kareem;\n"]}