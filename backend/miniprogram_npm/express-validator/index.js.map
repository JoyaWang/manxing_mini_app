{"version":3,"sources":["index.js","middlewares/one-of.js","chain/index.js","chain/sanitizers.js","chain/sanitizers-impl.js","context-items/sanitization.js","utils.js","chain/context-handler.js","chain/context-runner.js","chain/validators.js","chain/validation-chain.js","context-builder.js","middlewares/validation-chain-builders.js","middlewares/check.js","middlewares/schema.js","matched-data.js","base.js","validation-result.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,ACHA,AHSA,ACHA;ACFA,ACHA,AHSA,ACHA;ACFA,ACHA,AHSA,ACHA;ACFA,AENA,AJYA,ACHA;ACFA,AENA,AJYA,ACHA;ACFA,AENA,AJYA,ACHA;ACFA,AENA,ACHA,ALeA,ACHA;ACFA,AENA,ACHA,ALeA,ACHA;ACFA,AENA,ACHA,ALeA,ACHA;ACFA,AENA,ACHA,ALeA,ACHA,AKfA;AJaA,AENA,ACHA,ALeA,ACHA,AKfA;AJaA,AENA,ACHA,ALeA,ACHA,AKfA;ACFA,ALeA,AENA,ACHA,ALeA,ACHA,AKfA;ACFA,ALeA,AENA,ACHA,ALeA,ACHA,AKfA;ACFA,ALeA,AENA,ACHA,ALeA,ACHA,AKfA;AELA,ANkBA,AENA,ACHA,ALeA,ACHA,AKfA;AELA,ANkBA,AENA,ACHA,ALeA,ACHA,AKfA;AELA,ANkBA,AENA,ACHA,AJYA,AKfA;AJaA,AENA,AKfA,AJYA,AJYA,AKfA;AJaA,AENA,AKfA,AJYA,AJYA,AKfA;AJaA,AENA,AKfA,AJYA,AJYA,AKfA;AJaA,AENA,AMlBA,ALeA,AJYA,AKfA;AJaA,AENA,AMlBA,ALeA,AJYA,AKfA;AFOA,AMlBA,ALeA,AJYA,AKfA;AFOA,AOrBA,ANkBA,AJYA,AKfA;AFOA,AOrBA,ANkBA,AJYA,AKfA;AFOA,AOrBA,ANkBA,AJYA,AKfA;AFOA,AOrBA,ANkBA,AJYA,AWjCA,ANkBA;AFOA,AOrBA,ANkBA,AJYA,AWjCA,ANkBA;AFOA,AOrBA,ANkBA,AJYA,AWjCA,ANkBA;AFOA,AOrBA,ANkBA,AQxBA,AZoCA,AWjCA,ANkBA;AFOA,AOrBA,ANkBA,AQxBA,AZoCA,AWjCA,ANkBA;AFOA,AOrBA,ANkBA,AQxBA,AZoCA,AWjCA,ANkBA;AFOA,AOrBA,ANkBA,AQxBA,AZoCA,AavCA,AFMA,ANkBA;AFOA,AOrBA,ANkBA,AQxBA,AZoCA,AavCA,AFMA,ANkBA;AFOA,AOrBA,ANkBA,AQxBA,AZoCA,AavCA,AFMA,ANkBA;AFOA,AOrBA,ANkBA,AU9BA,AFMA,AZoCA,AavCA,AFMA,ANkBA;AFOA,AOrBA,ANkBA,AU9BA,AFMA,AZoCA,AavCA,AFMA,ANkBA;AFOA,AOrBA,ANkBA,AU9BA,AFMA,AZoCA,AavCA,AFMA,ANkBA;AU7BA,AZoCA,AOrBA,ANkBA,AU9BA,AFMA,AZoCA,AavCA,AFMA,ANkBA;AU7BA,AZoCA,AOrBA,ANkBA,AU9BA,AFMA,AZoCA,AavCA,AFMA,ANkBA;AU7BA,AZoCA,AOrBA,AIZA,AFMA,AZoCA,AavCA,AFMA,ANkBA;AU7BA,AZoCA,AOrBA,AIZA,AFMA,AZoCA,AavCA,AFMA,ANkBA,AWjCA;ADIA,AZoCA,AOrBA,AIZA,AFMA,AZoCA,AavCA,AFMA,ANkBA,AWjCA;ADIA,AZoCA,AOrBA,AIZA,AFMA,AZoCA,AavCA,AFMA,ANkBA,AWjCA;ADIA,AZoCA,AOrBA,AIZA,AFMA,AZoCA,AavCA,AFMA,ANkBA,AWjCA;ADIA,AZoCA,AOrBA,AIZA,AFMA,AZoCA,AavCA,AFMA,ANkBA,AWjCA;ADIA,AZoCA,AOrBA,AIZA,AFMA,AZoCA,AavCA,AFMA,ANkBA,AWjCA;AbwCA,AOrBA,AIZA,AFMA,AZoCA,AavCA,AFMA,ANkBA,AWjCA;AbwCA,AOrBA,AIZA,AFMA,AZoCA,AavCA,AFMA,ANkBA,AWjCA;AbwCA,AOrBA,AIZA,AFMA,AZoCA,AavCA,AFMA,ANkBA,AWjCA;AbwCA,AOrBA,AIZA,AFMA,AZoCA,AavCA,AFMA,ANkBA,AWjCA;AbwCA,AOrBA,AIZA,AFMA,AZoCA,AavCA,AFMA,ANkBA,AWjCA;AbwCA,AOrBA,AIZA,AFMA,AZoCA,AavCA,AFMA,ANkBA,AWjCA;AbwCA,AOrBA,AIZA,Ad0CA,AavCA,AFMA,ANkBA,AWjCA;AbwCA,AOrBA,AIZA,Ad0CA,AavCA,AFMA,ANkBA,AWjCA;AbwCA,AOrBA,AIZA,Ad0CA,AavCA,AFMA,ANkBA,AWjCA;AbwCA,AOrBA,AIZA,Ad0CA,AavCA,AFMA,ANkBA,AWjCA;AbwCA,AOrBA,AIZA,Ad0CA,AavCA,AFMA,ANkBA,AWjCA;AbwCA,AOrBA,AIZA,Ad0CA,AavCA,AFMA,ANkBA,AWjCA;AbwCA,AOrBA,AIZA,Ad0CA,AavCA,AFMA,ANkBA,AWjCA;AbwCA,AOrBA,AIZA,Ad0CA,AavCA,AFMA,ANkBA,AWjCA;AbwCA,AOrBA,AIZA,Ad0CA,AavCA,AFMA,ANkBA,AWjCA;AbwCA,AOrBA,AIZA,Ad0CA,AavCA,AFMA,ANkBA,AWjCA;AbwCA,AOrBA,AIZA,Ad0CA,AavCA,AFMA,ANkBA,AWjCA;AbwCA,AOrBA,AIZA,Ad0CA,AavCA,AFMA,ANkBA,AWjCA;AbwCA,AOrBA,AIZA,Ad0CA,AavCA,AFMA,AKfA;AbwCA,AOrBA,AIZA,Ad0CA,AavCA,AFMA,AKfA;AbwCA,AOrBA,AIZA,Ad0CA,AavCA,AFMA,AKfA;AbwCA,AOrBA,AIZA,Ad0CA,AavCA,AFMA,AKfA;AbwCA,AOrBA,AIZA,Ad0CA,AavCA,AFMA,AKfA;AbwCA,AOrBA,AIZA,Ad0CA,AavCA,AFMA,AKfA;AbwCA,AOrBA,AIZA,Ad0CA,AavCA,AFMA,AKfA;AbwCA,AOrBA,AIZA,Ad0CA,AavCA,AFMA,AKfA;AbwCA,AOrBA,AIZA,Ad0CA,AavCA,AFMA,AKfA;AbwCA,AOrBA,AIZA,Ad0CA,AavCA,AFMA,AKfA;AbwCA,AOrBA,AIZA,Ad0CA,AavCA,AFMA,AKfA;AbwCA,AWjCA,Ad0CA,AavCA,AGTA;AbwCA,AWjCA,Ad0CA,AavCA,AGTA;AbwCA,AWjCA,Ad0CA,AavCA,AGTA;AbwCA,AWjCA,Ad0CA,AavCA,AGTA;AbwCA,AWjCA,Ad0CA,AavCA,AGTA;AbwCA,AHSA,AavCA,AGTA;AbwCA,AHSA,AavCA,AGTA;AhBiDA,AavCA,AGTA;AhBiDA,AavCA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkSchema = void 0;\n__exportStar(require(\"./middlewares/exact\"), exports);\n__exportStar(require(\"./middlewares/one-of\"), exports);\n__exportStar(require(\"./middlewares/validation-chain-builders\"), exports);\nvar schema_1 = require(\"./middlewares/schema\");\nObject.defineProperty(exports, \"checkSchema\", { enumerable: true, get: function () { return schema_1.checkSchema; } });\n__exportStar(require(\"./matched-data\"), exports);\n__exportStar(require(\"./validation-result\"), exports);\n__exportStar(require(\"./express-validator\"), exports);\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.oneOf = oneOf;\nconst _ = require(\"lodash\");\nconst chain_1 = require(\"../chain\");\nconst context_builder_1 = require(\"../context-builder\");\nconst utils_1 = require(\"../utils\");\n// A dummy context item that gets added to surrogate contexts just to make them run\nconst dummyItem = { async run() { } };\n/**\n * Creates a middleware that will ensure that at least one of the given validation chains\n * or validation chain groups are valid.\n *\n * If none are, a single `AlternativeValidationError` or `GroupedAlternativeValidationError`\n * is added to the request, with the errors of each chain made available under the `nestedErrors` property.\n *\n * @param chains an array of validation chains to check if are valid.\n *               If any of the items of `chains` is an array of validation chains, then all of them\n *               must be valid together for the request to be considered valid.\n */\nfunction oneOf(chains, options = {}) {\n    const run = async (req, opts) => {\n        const surrogateContext = new context_builder_1.ContextBuilder().addItem(dummyItem).build();\n        // Run each group of chains in parallel\n        const promises = chains.map(async (chain) => {\n            const group = Array.isArray(chain) ? chain : [chain];\n            const results = await (0, utils_1.runAllChains)(req, group, { dryRun: true });\n            const { contexts, groupErrors } = results.reduce(({ contexts, groupErrors }, result) => {\n                const { context } = result;\n                contexts.push(context);\n                const fieldErrors = context.errors.filter((error) => error.type === 'field');\n                groupErrors.push(...fieldErrors);\n                return { contexts, groupErrors };\n            }, {\n                contexts: [],\n                groupErrors: [],\n            });\n            // #536: The data from a chain within oneOf() can only be made available to e.g. matchedData()\n            // if its entire group is valid.\n            if (!groupErrors.length) {\n                contexts.forEach(context => {\n                    surrogateContext.addFieldInstances(context.getData());\n                });\n            }\n            return groupErrors;\n        });\n        const allErrors = await Promise.all(promises);\n        const success = allErrors.some(groupErrors => groupErrors.length === 0);\n        if (!success) {\n            const message = options.message || 'Invalid value(s)';\n            switch (options.errorType) {\n                case 'flat':\n                    surrogateContext.addError({\n                        type: 'alternative',\n                        req,\n                        message,\n                        nestedErrors: _.flatMap(allErrors),\n                    });\n                    break;\n                case 'least_errored':\n                    let leastErroredIndex = 0;\n                    for (let i = 1; i < allErrors.length; i++) {\n                        if (allErrors[i].length < allErrors[leastErroredIndex].length) {\n                            leastErroredIndex = i;\n                        }\n                    }\n                    surrogateContext.addError({\n                        type: 'alternative',\n                        req,\n                        message,\n                        nestedErrors: allErrors[leastErroredIndex],\n                    });\n                    break;\n                case 'grouped':\n                default:\n                    // grouped\n                    surrogateContext.addError({\n                        type: 'alternative_grouped',\n                        req,\n                        message,\n                        nestedErrors: allErrors,\n                    });\n                    break;\n            }\n        }\n        // Final context running pass to ensure contexts are added and values are modified properly\n        return await new chain_1.ContextRunnerImpl(surrogateContext).run(req, opts);\n    };\n    const middleware = (req, _res, next) => run(req).then(() => next(), next);\n    return Object.assign(middleware, { run });\n}\n","\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./sanitizers\"), exports);\n__exportStar(require(\"./sanitizers-impl\"), exports);\n__exportStar(require(\"./context-handler\"), exports);\n__exportStar(require(\"./context-handler-impl\"), exports);\n__exportStar(require(\"./context-runner\"), exports);\n__exportStar(require(\"./context-runner-impl\"), exports);\n__exportStar(require(\"./validators\"), exports);\n__exportStar(require(\"./validators-impl\"), exports);\n__exportStar(require(\"./validation-chain\"), exports);\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SanitizersImpl = void 0;\nconst _ = require(\"lodash\");\nconst validator = require(\"validator\");\nconst sanitization_1 = require(\"../context-items/sanitization\");\nclass SanitizersImpl {\n    constructor(builder, chain) {\n        this.builder = builder;\n        this.chain = chain;\n    }\n    // custom sanitizers\n    customSanitizer(sanitizer) {\n        this.builder.addItem(new sanitization_1.Sanitization(sanitizer, true));\n        return this.chain;\n    }\n    default(default_value) {\n        return this.customSanitizer(value => [undefined, null, NaN, ''].includes(value) ? _.cloneDeep(default_value) : value);\n    }\n    replace(values_to_replace, new_value) {\n        if (!Array.isArray(values_to_replace)) {\n            values_to_replace = [values_to_replace];\n        }\n        return this.customSanitizer(value => values_to_replace.includes(value) ? _.cloneDeep(new_value) : value);\n    }\n    // Standard sanitizers\n    addStandardSanitization(sanitizer, ...options) {\n        this.builder.addItem(new sanitization_1.Sanitization(sanitizer, false, options));\n        return this.chain;\n    }\n    blacklist(chars) {\n        return this.addStandardSanitization(validator.blacklist, chars);\n    }\n    escape() {\n        return this.addStandardSanitization(validator.escape);\n    }\n    unescape() {\n        return this.addStandardSanitization(validator.unescape);\n    }\n    ltrim(chars) {\n        return this.addStandardSanitization(validator.ltrim, chars);\n    }\n    normalizeEmail(options) {\n        return this.addStandardSanitization(validator.normalizeEmail, options);\n    }\n    rtrim(chars) {\n        return this.addStandardSanitization(validator.rtrim, chars);\n    }\n    stripLow(keep_new_lines) {\n        return this.addStandardSanitization(validator.stripLow, keep_new_lines);\n    }\n    toArray() {\n        return this.customSanitizer(value => (value !== undefined && ((Array.isArray(value) && value) || [value])) || []);\n    }\n    toBoolean(strict) {\n        return this.addStandardSanitization(validator.toBoolean, strict);\n    }\n    toDate() {\n        return this.addStandardSanitization(validator.toDate);\n    }\n    toFloat() {\n        return this.addStandardSanitization(validator.toFloat);\n    }\n    toInt(radix) {\n        return this.addStandardSanitization(validator.toInt, radix);\n    }\n    toLowerCase() {\n        return this.customSanitizer(value => (typeof value === 'string' ? value.toLowerCase() : value));\n    }\n    toUpperCase() {\n        return this.customSanitizer(value => (typeof value === 'string' ? value.toUpperCase() : value));\n    }\n    trim(chars) {\n        return this.addStandardSanitization(validator.trim, chars);\n    }\n    whitelist(chars) {\n        return this.addStandardSanitization(validator.whitelist, chars);\n    }\n}\nexports.SanitizersImpl = SanitizersImpl;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Sanitization = void 0;\nconst utils_1 = require(\"../utils\");\nclass Sanitization {\n    constructor(sanitizer, custom, options = [], \n    // For testing only.\n    // Deliberately not calling it `toString` in order to not override `Object.prototype.toString`.\n    stringify = utils_1.toString) {\n        this.sanitizer = sanitizer;\n        this.custom = custom;\n        this.options = options;\n        this.stringify = stringify;\n    }\n    async run(context, value, meta) {\n        const { path, location } = meta;\n        const runCustomSanitizer = async () => {\n            const sanitizerValue = this.sanitizer(value, meta);\n            return Promise.resolve(sanitizerValue);\n        };\n        if (this.custom) {\n            const newValue = await runCustomSanitizer();\n            context.setData(path, newValue, location);\n            return;\n        }\n        const values = Array.isArray(value) ? value : [value];\n        const newValues = values.map(value => {\n            return this.sanitizer(this.stringify(value), ...this.options);\n        });\n        // We get only the first value of the array if the orginal value was wrapped.\n        context.setData(path, values !== value ? newValues[0] : newValues, location);\n    }\n}\nexports.Sanitization = Sanitization;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.bindAll = void 0;\nexports.toString = toString;\nexports.runAllChains = runAllChains;\nconst bindAll = (object) => {\n    const protoKeys = Object.getOwnPropertyNames(Object.getPrototypeOf(object));\n    protoKeys.forEach(key => {\n        const maybeFn = object[key];\n        if (typeof maybeFn === 'function' && key !== 'constructor') {\n            object[key] = maybeFn.bind(object);\n        }\n    });\n    return object;\n};\nexports.bindAll = bindAll;\nfunction toString(value) {\n    if (value instanceof Date) {\n        return value.toISOString();\n    }\n    else if (value && typeof value === 'object' && value.toString) {\n        if (typeof value.toString !== 'function') {\n            return Object.getPrototypeOf(value).toString.call(value);\n        }\n        return value.toString();\n    }\n    else if (value == null || (isNaN(value) && !value.length)) {\n        return '';\n    }\n    return String(value);\n}\n/**\n * Runs all validation chains, and returns their results.\n *\n * If one of them has a request-level bail set, the previous chains will be awaited on so that\n * results are not skewed, which can be slow.\n * If this same chain also contains errors, no further chains are run.\n */\nasync function runAllChains(req, chains, runOpts) {\n    const promises = [];\n    for (const chain of chains) {\n        const bails = chain.builder.build().bail;\n        if (bails) {\n            await Promise.all(promises);\n        }\n        const resultPromise = chain.run(req, runOpts);\n        promises.push(resultPromise);\n        if (bails) {\n            const result = await resultPromise;\n            if (!result.isEmpty()) {\n                break;\n            }\n        }\n    }\n    return Promise.all(promises);\n}\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ContextBuilder = void 0;\nconst context_1 = require(\"./context\");\nclass ContextBuilder {\n    constructor() {\n        this.stack = [];\n        this.fields = [];\n        this.locations = [];\n        this.optional = false;\n        this.requestBail = false;\n        this.visibility = { type: 'visible' };\n    }\n    setFields(fields) {\n        this.fields = fields;\n        return this;\n    }\n    setLocations(locations) {\n        this.locations = locations;\n        return this;\n    }\n    setMessage(message) {\n        this.message = message;\n        return this;\n    }\n    addItem(...items) {\n        this.stack.push(...items);\n        return this;\n    }\n    setOptional(options) {\n        this.optional = options;\n        return this;\n    }\n    setRequestBail() {\n        this.requestBail = true;\n        return this;\n    }\n    setHidden(hidden, hiddenValue) {\n        if (hidden) {\n            this.visibility =\n                hiddenValue !== undefined ? { type: 'redacted', value: hiddenValue } : { type: 'hidden' };\n        }\n        else {\n            this.visibility = { type: 'visible' };\n        }\n        return this;\n    }\n    build() {\n        return new context_1.Context(this.fields, this.locations, this.stack, this.optional, this.requestBail, this.visibility, this.message);\n    }\n}\nexports.ContextBuilder = ContextBuilder;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.query = exports.param = exports.header = exports.cookie = exports.body = exports.check = void 0;\nexports.buildCheckFunction = buildCheckFunction;\nconst check_1 = require(\"./check\");\n/**\n * Creates a variant of `check()` that checks the given request locations.\n *\n * @example\n *  const checkBodyAndQuery = buildCheckFunction(['body', 'query']);\n */\nfunction buildCheckFunction(locations) {\n    return (fields, message) => (0, check_1.check)(fields, locations, message);\n}\n/**\n * Creates a middleware/validation chain for one or more fields that may be located in\n * any of the following:\n *\n * - `req.body`\n * - `req.cookies`\n * - `req.headers`\n * - `req.params`\n * - `req.query`\n *\n * @param fields  a string or array of field names to validate/sanitize\n * @param message an error message to use when failed validations don't specify a custom message.\n *                Defaults to `Invalid Value`.\n */\nexports.check = buildCheckFunction(['body', 'cookies', 'headers', 'params', 'query']);\n/**\n * Same as {@link check()}, but only validates `req.body`.\n */\nexports.body = buildCheckFunction(['body']);\n/**\n * Same as {@link check()}, but only validates `req.cookies`.\n */\nexports.cookie = buildCheckFunction(['cookies']);\n/**\n * Same as {@link check()}, but only validates `req.headers`.\n */\nexports.header = buildCheckFunction(['headers']);\n/**\n * Same as {@link check()}, but only validates `req.params`.\n */\nexports.param = buildCheckFunction(['params']);\n/**\n * Same as {@link check()}, but only validates `req.query`.\n */\nexports.query = buildCheckFunction(['query']);\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.check = check;\nconst chain_1 = require(\"../chain\");\nconst context_builder_1 = require(\"../context-builder\");\nconst utils_1 = require(\"../utils\");\nfunction check(fields = '', locations = [], message) {\n    const builder = new context_builder_1.ContextBuilder()\n        .setFields(Array.isArray(fields) ? fields : [fields])\n        .setLocations(locations)\n        .setMessage(message);\n    const runner = new chain_1.ContextRunnerImpl(builder);\n    const middleware = async (req, _res, next) => {\n        try {\n            await runner.run(req);\n            next();\n        }\n        catch (e) {\n            next(e);\n        }\n    };\n    return Object.assign(middleware, (0, utils_1.bindAll)(runner), (0, utils_1.bindAll)(new chain_1.SanitizersImpl(builder, middleware)), (0, utils_1.bindAll)(new chain_1.ValidatorsImpl(builder, middleware)), (0, utils_1.bindAll)(new chain_1.ContextHandlerImpl(builder, middleware)), { builder });\n}\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkSchema = void 0;\nexports.createCheckSchema = createCheckSchema;\nconst _ = require(\"lodash\");\nconst chain_1 = require(\"../chain\");\nconst utils_1 = require(\"../utils\");\nconst check_1 = require(\"./check\");\nconst validLocations = ['body', 'cookies', 'headers', 'params', 'query'];\nconst protectedNames = ['errorMessage', 'in', 'optional'];\n/**\n * Factory for a {@link checkSchema()} function which can have extension validators and sanitizers.\n *\n * @see {@link checkSchema()}\n */\nfunction createCheckSchema(createChain, extraValidators = [], extraSanitizers = []) {\n    /** Type guard for an object entry for a standard validator. */\n    function isStandardValidator(entry) {\n        return (\n        // #664 - explicitly exclude properties which should be set per validator\n        !['not', 'withMessage'].includes(entry[0]) &&\n            (entry[0] in chain_1.ValidatorsImpl.prototype || extraValidators.includes(entry[0])) &&\n            entry[1]);\n    }\n    /** Type guard for an object entry for a standard sanitizer. */\n    function isStandardSanitizer(entry) {\n        return ((entry[0] in chain_1.SanitizersImpl.prototype || extraSanitizers.includes(entry[0])) &&\n            entry[1]);\n    }\n    /** Type guard for an object entry for a custom validator. */\n    function isCustomValidator(entry) {\n        return (!isStandardValidator(entry) &&\n            !isStandardSanitizer(entry) &&\n            typeof entry[1] === 'object' &&\n            entry[1] &&\n            typeof entry[1].custom === 'function');\n    }\n    /** Type guard for an object entry for a custom sanitizer. */\n    function isCustomSanitizer(entry) {\n        return (!isStandardValidator(entry) &&\n            !isStandardSanitizer(entry) &&\n            typeof entry[1] === 'object' &&\n            entry[1] &&\n            typeof entry[1].customSanitizer === 'function');\n    }\n    return (schema, defaultLocations = validLocations) => {\n        const chains = Object.keys(schema).map(field => {\n            const config = schema[field];\n            const chain = createChain(field, ensureLocations(config, defaultLocations), config.errorMessage);\n            // optional doesn't matter where it happens in the chain\n            if (config.optional) {\n                chain.optional(config.optional === true ? true : config.optional.options);\n            }\n            for (const entry of Object.entries(config)) {\n                if (protectedNames.includes(entry[0]) || !entry[1]) {\n                    continue;\n                }\n                if (!isStandardValidator(entry) &&\n                    !isStandardSanitizer(entry) &&\n                    !isCustomValidator(entry) &&\n                    !isCustomSanitizer(entry)) {\n                    console.warn(`express-validator: schema of \"${field}\" has unknown validator/sanitizer \"${entry[0]}\"`);\n                    continue;\n                }\n                // For validators, stuff that must come _before_ the validator itself in the chain.\n                if ((isStandardValidator(entry) || isCustomValidator(entry)) && entry[1] !== true) {\n                    const [, validatorConfig] = entry;\n                    validatorConfig.if && chain.if(validatorConfig.if);\n                    validatorConfig.negated && chain.not();\n                }\n                if (isStandardValidator(entry) || isStandardSanitizer(entry)) {\n                    const options = entry[1] ? (entry[1] === true ? [] : _.castArray(entry[1].options)) : [];\n                    chain[entry[0]](...options);\n                }\n                if (isCustomValidator(entry)) {\n                    chain.custom(entry[1].custom);\n                }\n                if (isCustomSanitizer(entry)) {\n                    chain.customSanitizer(entry[1].customSanitizer);\n                }\n                // For validators, stuff that must come _after_ the validator itself in the chain.\n                if ((isStandardValidator(entry) || isCustomValidator(entry)) && entry[1] !== true) {\n                    const [, validatorConfig] = entry;\n                    validatorConfig.bail &&\n                        chain.bail(validatorConfig.bail === true ? {} : validatorConfig.bail);\n                    validatorConfig.errorMessage && chain.withMessage(validatorConfig.errorMessage);\n                }\n            }\n            return chain;\n        });\n        const run = async (req) => (0, utils_1.runAllChains)(req, chains);\n        return Object.assign(chains, { run });\n    };\n}\n/**\n * Creates an express middleware with validations for multiple fields at once in the form of\n * a schema object.\n *\n * @param schema the schema to validate.\n * @param defaultLocations\n * @returns\n */\nexports.checkSchema = createCheckSchema(check_1.check);\nfunction ensureLocations(config, defaults) {\n    // .filter(Boolean) is done because in can be undefined -- which is not going away from the type\n    // See https://github.com/Microsoft/TypeScript/pull/29955 for details\n    const locations = Array.isArray(config.in)\n        ? config.in\n        : [config.in].filter(Boolean);\n    const actualLocations = locations.length ? locations : defaults;\n    return actualLocations.filter(location => validLocations.includes(location));\n}\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.matchedData = matchedData;\nconst _ = require(\"lodash\");\nconst base_1 = require(\"./base\");\n/**\n * Extracts data validated or sanitized from the request, and builds an object with them.\n *\n * @param req the express request object\n * @param options\n * @returns an object of data that's been validated or sanitized in the passed request\n */\nfunction matchedData(req, options = {}) {\n    const internalReq = req;\n    const fieldExtractor = createFieldExtractor(options.includeOptionals !== true);\n    const validityFilter = createValidityFilter(options.onlyValidData);\n    const locationFilter = createLocationFilter(options.locations);\n    return _(internalReq[base_1.contextsKey])\n        .flatMap(fieldExtractor)\n        .filter(validityFilter)\n        .map(field => field.instance)\n        .filter(locationFilter)\n        .reduce((state, instance) => _.set(state, instance.path, instance.value), {});\n}\nfunction createFieldExtractor(removeOptionals) {\n    return (context) => {\n        const instances = context.getData({ requiredOnly: removeOptionals });\n        return instances.map((instance) => ({ instance, context }));\n    };\n}\nfunction createValidityFilter(onlyValidData = true) {\n    return !onlyValidData\n        ? () => true\n        : (field) => {\n            const hasError = field.context.errors.some(error => error.type === 'field' &&\n                error.location === field.instance.location &&\n                error.path === field.instance.path);\n            return !hasError;\n        };\n}\nfunction createLocationFilter(locations = []) {\n    // No locations mean all locations\n    const allLocations = locations.length === 0;\n    return allLocations ? () => true : (field) => locations.includes(field.location);\n}\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ValidationHalt = exports.contextsKey = void 0;\n// Not using Symbol because of #813\nexports.contextsKey = 'express-validator#contexts';\nclass ValidationHalt extends Error {\n}\nexports.ValidationHalt = ValidationHalt;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Result = exports.validationResult = void 0;\nconst _ = require(\"lodash\");\nconst base_1 = require(\"./base\");\nconst utils_1 = require(\"./utils\");\n/**\n * Extracts the validation errors of an express request\n */\nexports.validationResult = Object.assign(withDefaults(), { withDefaults });\n/**\n * The current state of the validation errors in a request.\n */\nclass Result {\n    constructor(formatter, errors) {\n        this.formatter = formatter;\n        this.errors = errors;\n    }\n    /**\n     * Gets the validation errors as an array.\n     *\n     * @param options.onlyFirstError whether only the first error of each\n     */\n    array(options) {\n        return options && options.onlyFirstError\n            ? Object.values(this.mapped())\n            : this.errors.map(this.formatter);\n    }\n    /**\n     * Gets the validation errors as an object.\n     * If a field has more than one error, only the first one is set in the resulting object.\n     *\n     * @returns an object from field name to error\n     */\n    mapped() {\n        return this.errors.reduce((mapping, error) => {\n            const key = error.type === 'field' ? error.path : `_${error.type}`;\n            if (!mapping[key]) {\n                mapping[key] = this.formatter(error);\n            }\n            return mapping;\n        }, {});\n    }\n    /**\n     * Specifies a function to format errors with.\n     * @param formatter the function to use for formatting errors\n     * @returns A new {@link Result} instance with the given formatter\n     */\n    formatWith(formatter) {\n        return new Result(formatter, this.errors);\n    }\n    /**\n     * @returns `true` if there are no errors, `false` otherwise\n     */\n    isEmpty() {\n        return this.errors.length === 0;\n    }\n    /**\n     * Throws an error if there are validation errors.\n     */\n    throw() {\n        if (!this.isEmpty()) {\n            throw Object.assign(new Error(), (0, utils_1.bindAll)(this));\n        }\n    }\n}\nexports.Result = Result;\n/**\n * Creates a `validationResult`-like function with default options passed to every {@link Result} it\n * returns.\n */\nfunction withDefaults(options = {}) {\n    const defaults = {\n        formatter: error => error,\n    };\n    const actualOptions = _.defaults(options, defaults);\n    return (req) => {\n        const contexts = req[base_1.contextsKey] || [];\n        const errors = _.flatMap(contexts, 'errors');\n        return new Result(actualOptions.formatter, errors);\n    };\n}\n"]}